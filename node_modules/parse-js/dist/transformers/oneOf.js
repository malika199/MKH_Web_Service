'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _isEmpty = require('lodash/isEmpty');

var _isObject = require('lodash/isObject');

var _merge = require('lodash/merge');

function isEmpty(v) {
  if (['boolean', 'number'].indexOf(_typeof(v)) > -1) return false;
  return _isEmpty(v);
}

function OneOfTransformer(parsers) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(this instanceof OneOfTransformer)) {
    return this.transform(new OneOfTransformer(parsers, options));
  }

  this._parsers = parsers;

  this._test = options.test || function (v) {
    return !isEmpty(v);
  };

  this._reverseAll = true;
  if (typeof options.reverseAll === 'boolean') this._reverseAll = options.reverseAll;
}

OneOfTransformer.prototype.parse = function (v, instance, root) {
  var parsers = this._parsers;
  var len = parsers.length;
  var test = this._test;

  for (var i = 0; i < len; i++) {
    var result = parsers[i].parse(v, instance, root);
    if (test(result)) return result;
  }

  return;
};

OneOfTransformer.prototype.reverse = function (v, instance, root) {
  var parsers = this._parsers;
  var len = parsers.length;
  if (len < 1) throw new Error('No parsers defined');
  if (!this._reverseAll) return parsers[0].reverse(v);
  var reversed = {};

  for (var i = 0; i < len; i++) {
    var result = parsers[i].reverse(v, instance, root);
    if (typeof result === 'undefined') continue;
    if (_isObject(reversed) && _isObject(result)) _merge(reversed, result);else reversed = result;
  }

  return reversed;
};

module.exports = OneOfTransformer;