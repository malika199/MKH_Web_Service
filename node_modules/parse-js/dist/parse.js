'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _set = require('lodash/set');

var _get = require('lodash/get');

var isString = require('lodash/isString');

var CustomTransformer = require('./transformers/custom');

var DIRECTION_ANY = 'ANY';
var DIRECTION_PARSE = 'PARSE';
var DIRECTION_REVERSE = 'REVERSE';

function Parse(path) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!(this instanceof Parse)) return new Parse(path, options);
  this._chain = [];
  this._options = options;
  if (isString(path)) return this.select(path);
  return this;
}

Parse.DIRECTION_ANY = DIRECTION_ANY;
Parse.DIRECTION_PARSE = DIRECTION_PARSE;
Parse.DIRECTION_REVERSE = DIRECTION_REVERSE;
module.exports = Parse;
Parse.options = {};

Parse.register = function (name, handler) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$overwrite = _ref.overwrite,
      overwrite = _ref$overwrite === void 0 ? false : _ref$overwrite;

  if (!overwrite && this.prototype[name]) throw new Error("".concat(name, " already has a handler."));
  this.prototype[name] = handler;
};

Parse.setOption = function (key, value) {
  _set(this.options, key, value);

  return Parse;
};

Parse.getOption = function (key) {
  return _get(this.options, key);
};

Parse.prototype.setOption = function (key, value) {
  _set(this._options, key, value);

  return this;
};

Parse.prototype.getOption = function (key) {
  return _get(this._options, key, this.constructor.getOption(key));
};

Parse.prototype.transform = function (parse, reverse) {
  if (_typeof(parse) !== 'object') {
    parse = new CustomTransformer(parse, reverse);
  }

  this._chain = this._chain.concat(parse);
  return this;
};

Parse.prototype.chain = function (configurator) {
  return configurator(this) || this;
};

Parse.prototype.isDirectionEnabled = function (direction) {
  direction = direction.toUpperCase();
  var configuredDirection = this.getOption('direction') || DIRECTION_ANY;
  var enabledDirection = configuredDirection.toUpperCase();
  if (DIRECTION_ANY == enabledDirection) return true;
  return [DIRECTION_ANY, enabledDirection].indexOf(direction) > -1;
};

Parse.prototype.parse = function (obj, instance) {
  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : obj;
  if (!this.isDirectionEnabled(DIRECTION_PARSE)) return obj;
  var len = this._chain.length;

  for (var i = 0; i < len; i++) {
    obj = this._chain[i].parse(obj, this, root);
  }

  return obj;
};

Parse.prototype.reverse = function (obj, instance) {
  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : obj;
  if (!this.isDirectionEnabled(DIRECTION_REVERSE)) return obj;
  var i = this._chain.length;

  while (i--) {
    obj = this._chain[i].reverse(obj, this, root);
  }

  return obj;
};